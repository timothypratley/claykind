<!DOCTYPE html>
<html><head><link href="style.css" rel="stylesheet" type="text/css"><script src="portal-main.js" type="text/javascript"></script><script src="https://scicloj.github.io/scittle/js/scittle.js" type="text/javascript"></script><script src="https://cdn.jsdelivr.net/npm/vega@5" type="text/javascript"></script><script src="https://cdn.jsdelivr.net/npm/vega-lite@5" type="text/javascript"></script><script src="https://cdn.jsdelivr.net/npm/vega-embed@6" type="text/javascript"></script><script src="https://unpkg.com/react@18/umd/react.production.min.js" type="text/javascript"></script><script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" type="text/javascript"></script><script src="https://scicloj.github.io/scittle/js/scittle.reagent.js" type="text/javascript"></script><script type="application/x-scittle">(require '[reagent.core :as r] '[reagent.dom :as dom])
</script></head><body><div><pre><code></code></pre><div><h1 id="try-again">Try Again</h1></div></div><div><pre><code></code></pre><div><p>One thing that I love about Clojure is that the Read-Eval-Print-Loop (REPL) enables me to redefine functions on the fly, without restarting anything. This makes trying things, making changes, and trying them again very fluid. Trying stuff, changing it, and trying it again pretty much sums up how I write code.</p></div></div><div><pre><code></code></pre><div><blockquote><p>If at first you don't succeed, dust yourself off and try again.</p><p>-- Aaliyah</p></blockquote></div></div><div><pre><code></code></pre><div><p>Today I'm going to share with you my favorite "try it again" tip, which is to bind keys to <em>try something</em> and <em>try it again</em>.</p></div></div><div><pre><code></code></pre><div><h2 id="repl-usage">REPL usage</h2></div></div><div><pre><code></code></pre><div><p>Let's recap basic REPL usage. I can type stuff into the REPL input window and evaluate some code. Generally I don't do that though. I'm not usually <em>in</em> the REPL, I'm <em>in</em> my source code sending forms to the REPL. To achieve that requires some essential key bindings.</p></div></div><div><pre><code></code></pre><div><table><thead><tr><th style="text-align:right;">Binding</th><th>Action</th></tr></thead><tbody><tr><td style="text-align:right;"><code>alt-t</code></td><td>Evaluate the expression before the cursor</td></tr><tr><td style="text-align:right;"><code>cmd-t</code></td><td>Evaluate top-level expression at the cursor</td></tr><tr><td style="text-align:right;"><code>ctrl-c</code></td><td>Run test under cursor</td></tr><tr><td style="text-align:right;"><code>shift-ctrl-c</code></td><td>Run all tests in namespace</td></tr><tr><td style="text-align:right;"><code>ctrl-c</code></td><td>Re-run last test action</td></tr></tbody></table></div></div><div><pre><code></code></pre><div><h2 id="the-problem-ðŸ˜¢">The Problem ðŸ˜¢</h2></div></div><div><pre><code></code></pre><div><p>A common scenario I find myself in is that I set up a little bit of code to try something. Then I make some changes, and need to retry the same snippet or test. In the meantime I have navigated away and I need to either go back to the form I am interested in, or navigate to the REPL and use history to try it again. Both of these strategies work, but there is a better way!</p></div></div><div><pre><code></code></pre><div><h2 id="the-solution-ðŸ’¡">The Solution ðŸ’¡</h2></div></div><div><pre><code></code></pre><div><p>The idea is to create a REPL command that creates a function in the <code>user</code> namespace. Then we can make a keybinding like "send form before caret to REPL", and another keybinding to execute the saved function. That way even if we send other forms to the REPL, we can conveniently retry the snippet we are focused on.</p></div></div><div><pre><code></code></pre><div><p>Here is how I set the "try" command up: <img alt="" class="inline" src="try-form-before-caret.png"></p></div></div><div><pre><code></code></pre><div><p>I use Cursive Clojure (IntelliJ). If you use a different editor, you can find instructions for creating key bound commands in the <a href="https://scicloj.github.io/clay/#setup">Clay setup documentation</a>.</p></div></div><div><pre><code></code></pre><div><p><code>~form-before-caret</code> gets replaced with code.</p></div></div><div><pre><code></code></pre><div><p>So if my cursor is at the end of an expression (cursor shown as <code>_</code>):</p></div></div><div><pre><code></code></pre><div><pre class="viewer-code not-prose">(+ 1 2)_
</pre></div></div><div><pre><code></code></pre><div><p>My editor will send the following code to the REPL:</p></div></div><div><pre><code></code></pre><div><pre class="viewer-code not-prose">(do (intern 'user 'retry (fn retry []
                           (+ 1 2)))
    (user/retry))
</pre></div></div><div><pre><code></code></pre><div><p>This creates the <code>retry</code> var in the <code>user</code> namespace (<code>user/retry</code>), and assigns it to a function that will run the code I am interested in.</p></div></div><div><pre><code></code></pre><div><p>It is worth considering a few questions about namespaces at this point. <em>Which namespace will the command execute in?</em> <em>How can <code>user/retry</code> "see" variables in the currently edited namespace?</em></p></div></div><div><pre><code></code></pre><div><p>The command will execute in the namespace of the file I am editing, because I configured the command to do so through Cursive. The function is created in the current namespace, because <code>(fn retry [] (+ 1 2))</code> is eagerly evaluated as an argument to <code>intern</code>. Because the function is created in the current namespace, <code>x</code> is resolved correctly. <code>user/retry</code> can be invoked from any namespace by the fully qualified name of the var <code>user/retry</code>.</p></div></div><div><pre><code></code></pre><div><p>Here is how I set the "retry" command which simply invokes <code>(user/retry)</code>: <img alt="" class="inline" src="retry-form.png"></p></div></div><div><pre><code></code></pre><div><p>And here are the keybindings for the commands I use: <img alt="" class="inline" src="retry-keybindings.png"></p></div></div><div><pre><code></code></pre><div><p>I've bound <code>alt-z</code> to <strong>"try form before caret"</strong> and <code>ctrl-z</code> to <strong>"retry"</strong>.</p></div></div><div><pre><code></code></pre><div><p>Now let's take it for a spin. Here is some code I've been working on; I'm drawing a heart shape.</p></div></div><div><pre><code>(def heart-path
  "M 12.0 7.2 C 10.5 5.6 8.1 5.2 6.3 6.7 C 4.5 8.1 4.2 10.6 5.7 12.4 L 12.0 18.3 L 18.3 12.4 C 19.7 10.6 19.5 8.1 17.7 6.7 C 15.8 5.2 13.4 5.6 12.0 7.2 Z")</code></pre></div><div><pre><code></code></pre><div><p>This shape comes from <a href="https://www.nan.fyi/svg-paths">svg-paths</a> by <a href="https://twitter.com/nandafyi">@nandafyi</a>.</p></div></div><div><pre><code></code></pre><div><p>I'll visualize it in an SVG image:</p></div></div><div><pre><code>(defn svg [& body]
  (into ^{:kindly/kind :kind/hiccup}
        [:svg {:width   256
               :height  256
               :viewBox [0 0 24 24]
               :xmlns   "http://www.w3.org/2000/svg"}]
        body))</code></pre></div><div><pre><code></code></pre><div><p>The heart path goes into an SVG element:</p></div></div><div><pre><code>(defn heart []
  [:path {:fill "green"
          :d    heart-path}])</code></pre></div><div><pre><code></code></pre><div><p>And to see what it looks like I'll make a <a href="https://www.youtube.com/watch?v=Qx0-pViyIDU&amp;t=1229s">"rich comment block"</a>:</p></div></div><div><pre><code></code></pre><div><pre class="viewer-code not-prose">(comment
  (svg (heart)))
</pre></div></div><div><pre><code></code></pre><div><p>The comment block allows me to conveniently send the expression <code>(svg (heart))</code> to the REPL, and of course we'll use my new <strong>"try form before caret"</strong> on it.</p></div></div><div><pre><code>(svg (heart))</code></pre><svg height="256" viewBox="0 0 24 24" width="256" xmlns="http://www.w3.org/2000/svg"><path d="M 12.0 7.2 C 10.5 5.6 8.1 5.2 6.3 6.7 C 4.5 8.1 4.2 10.6 5.7 12.4 L 12.0 18.3 L 18.3 12.4 C 19.7 10.6 19.5 8.1 17.7 6.7 C 15.8 5.2 13.4 5.6 12.0 7.2 Z" fill="green"></path></svg></div><div><pre><code></code></pre><div><p>Now I can navigate throughout my code base, making changes and fixes, and seeing the effect is just one keystroke away with <strong>"retry"</strong>:</p></div></div><div><pre><code>(defn heart []
  [:path {:fill "red"
          :d    heart-path}])</code></pre></div><div><pre><code>(svg (heart))</code></pre><svg height="256" viewBox="0 0 24 24" width="256" xmlns="http://www.w3.org/2000/svg"><path d="M 12.0 7.2 C 10.5 5.6 8.1 5.2 6.3 6.7 C 4.5 8.1 4.2 10.6 5.7 12.4 L 12.0 18.3 L 18.3 12.4 C 19.7 10.6 19.5 8.1 17.7 6.7 C 15.8 5.2 13.4 5.6 12.0 7.2 Z" fill="red"></path></svg></div><div><pre><code></code></pre><div><p>Setting up the command to sync all changes before executing makes it easy to test changes as I go, often I can rely on syncing instead of sending updates to the REPL individually.</p></div></div><div><pre><code></code></pre><div><p>Special thanks to <a href="https://twitter.com/chrishouser">@chrishouser</a> and Jon Boone for dedicating a session of <a href="https://chouser.us/lisp2022/">LiSP reading group</a> to improving my workflow with try/retry.</p></div></div></body></html>